{"version":3,"file":"action-form.js","sources":["../src/helpers.ts","../src/af-error.ts","../src/reactiveFormData.ts","../src/reactiveStepData.ts","../src/action-form.ts"],"sourcesContent":["import type { HTMLFormField } from \"./types\";\nimport ActionFormFieldGroup from \"./af-field-group\";\n\nexport function randomId(prefix = \"\"): string {\n\treturn `${prefix ? prefix + \"-\" : \"\"}${Math.random().toString(36).substring(2, 9)}`;\n}\n\nexport function isField(el: Element | null | undefined): el is HTMLFormField {\n\treturn !!el && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement);\n}\n\nexport function isFieldOrGroup(el: Element | null | undefined): el is HTMLFormField | ActionFormFieldGroup {\n\treturn !!el && (isField(el) || el instanceof ActionFormFieldGroup);\n}\n\nexport function isHTMLFormElement(el: Element | null | undefined): el is HTMLFormField | HTMLFieldSetElement {\n\treturn !!el && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement || el instanceof HTMLFieldSetElement);\n}\n","import { randomId, isFieldOrGroup } from \"./helpers\";\n\nexport default class ActionFormError extends HTMLElement {\n\tpublic target: HTMLFormElement | null = null;\n\tprivate readonly shadow = this.attachShadow({ mode: \"open\" });\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tprivate addAria(target: HTMLElement) {\n\t\t// skip if target is not a form element or if it already has a matching aria-describedby\n\t\tif (isFieldOrGroup(target)) {\n\t\t\t// get id of this af-error element either from the aria-describedby attribute or from itself or make one\n\t\t\tconst id = target.getAttribute(\"aria-describedby\") || this.getAttribute(\"id\") || randomId(target.id);\n\n\t\t\t// set the id on this element and the aria-describedby\n\t\t\tthis.setAttribute(\"id\", id);\n\t\t\ttarget.setAttribute(\"aria-describedby\", id);\n\t\t}\n\t}\n\n\tpublic connectedCallback(): void {\n\t\t// hide by default\n\t\tthis.style.visibility = \"hidden\";\n\t\t// get target from attribute\n\t\tconst targetId = this.getAttribute(\"for\") || \"\";\n\t\tconst target = targetId ? document.getElementById(targetId) : this.closest(\"label\")?.querySelector(`input, select, textarea`);\n\t\t// get field ID from attribute\n\t\tif (isFieldOrGroup(target)) {\n\t\t\t// Make id and add aria-describedby attribute to the target element\n\t\t\tthis.addAria(target);\n\t\t\t// render the element\n\t\t\tthis.render();\n\t\t}\n\t}\n\n\tstatic get observedAttributes() {\n\t\treturn [\"data-invalid\"];\n\t}\n\n\tpublic attributeChangedCallback(name: string, _oldValue: string, newValue: string) {\n\t\t// console.log(\"changed\", name, oldValue, newValue);\n\t\tif (name === \"data-invalid\" && (newValue === \"pattern\" || newValue === \"required\")) {\n\t\t\t// rerender based on pattern or required\n\t\t\tthis.render(newValue);\n\t\t}\n\t}\n\n\tpublic render(part: \"pattern\" | \"required\" = \"required\") {\n\t\tconst parts = {\n\t\t\trequired: `<slot>Required</slot>`,\n\t\t\tpattern: `<slot name=\"pattern\">Not filled in properly</slot>`,\n\t\t};\n\t\tthis.shadow.innerHTML = parts[part];\n\t}\n}\n","import { createSignal } from \"./signals\";\n\nexport function formSignals(form: HTMLFormElement) {\n\tconst map = new Map<string, { get: () => FormDataEntryValue[]; set: (value: FormDataEntryValue[]) => void }>();\n\n\t// Save form data\n\tconst [getForm, setFormData] = createSignal<Record<string, FormDataEntryValue[]>>(formDataObject());\n\n\tfunction setForm() {\n\t\tsetFormData(formDataObject());\n\t}\n\n\tfunction set(key: string) {\n\t\tconst values = getValues(key);\n\t\tif (map.has(key)) {\n\t\t\t// @ts-expect-error already checked if key is exists\n\t\t\tmap.get(key).set(values);\n\t\t} else {\n\t\t\tconst [get, set] = createSignal(values);\n\t\t\tmap.set(key, { get, set });\n\t\t}\n\t}\n\n\tfunction get(key: string) {\n\t\treturn map.get(key)?.get();\n\t}\n\n\tfunction getValues(name: string) {\n\t\treturn new FormData(form).getAll(name);\n\t}\n\n\tfunction formDataObject() {\n\t\tconst keys = new FormData(form).keys();\n\t\tconst tempObject: Record<string, FormDataEntryValue[]> = {};\n\t\tArray.from(keys).forEach((key) => {\n\t\t\ttempObject[key] = getValues(key);\n\t\t});\n\t\treturn tempObject;\n\t}\n\n\treturn {\n\t\tset,\n\t\tget,\n\t\tgetForm,\n\t\tsetForm,\n\t\tformDataObject,\n\t};\n}\n","export type StepEvent = (data: { index: number; currentStep: HTMLElement }) => void;\n\nimport { createSignal } from \"./signals\";\nimport ActionFormStep from \"./af-step\";\n\nexport function stepSignals(afSteps: NodeListOf<ActionFormStep>) {\n\t// create signal with initial step index and the first step\n\tconst [stepIndex, setStepIndex] = createSignal(0);\n\tconst [currentStep, setCurrentStep] = createSignal(getVisible()[0]);\n\tconst [stepsLength, setStepsLength] = createSignal(getVisible().length);\n\n\tfunction getVisible() {\n\t\treturn Array.from(afSteps).filter((step) => step.style.display !== \"none\");\n\t}\n\n\tfunction updateSteps() {\n\t\tsetStepsLength(getVisible().length);\n\t}\n\n\tfunction set(number: number = 0) {\n\t\tsetStepIndex(number);\n\t\tsetCurrentStep(getVisible()[number]);\n\t}\n\n\tfunction move(numberOfSteps: number = 0) {\n\t\tconst currentIndex = stepIndex();\n\t\tconst index = Math.max(0, Math.min(currentIndex + numberOfSteps, getVisible().length - 1));\n\t\tif (index === currentIndex) return;\n\t\tset(index);\n\t}\n\n\tfunction prev() {\n\t\tmove(-1);\n\t}\n\n\tfunction next() {\n\t\t// Check for invalid fields before moving to next step\n\t\tconst invalid = currentStep().querySelector(\":invalid:not(fieldset)\");\n\t\tif (invalid instanceof HTMLElement) {\n\t\t\t// focus on the first element that is invalid\n\t\t\tinvalid.focus();\n\t\t\t// dispatch change event to trigger subscribed toggleError method\n\t\t\tinvalid.dispatchEvent(new Event(\"change\", { bubbles: true, composed: true }));\n\t\t} else {\n\t\t\tmove(1);\n\t\t}\n\t}\n\n\treturn {\n\t\tall: afSteps,\n\t\t// function which updates when called\n\t\tgetVisible,\n\t\t// reactive current step element\n\t\tcurrentStep,\n\t\t// reactive step index\n\t\tstepIndex,\n\t\t// reactive steps length of visible steps\n\t\tstepsLength,\n\t\t// update stepsLength\n\t\tupdateSteps,\n\t\t// set reactive step index and reactive current step\n\t\tset,\n\t\t// move a number of steps forward or backward\n\t\tmove,\n\t\t// move to previous step\n\t\tprev,\n\t\t// move to next step\n\t\tnext,\n\t};\n}\n","import type ActionFormStep from \"./af-step\";\nimport ActionFormError from \"./af-error\";\nimport ActionFormFieldGroup from \"./af-field-group\";\nimport type { HTMLFormField } from \"./types\";\nimport { formSignals } from \"./reactiveFormData\";\nimport { randomId, isField, isFieldOrGroup } from \"./helpers\";\nimport { stepSignals } from \"./reactiveStepData\";\nimport { createEffect } from \"./signals\";\n\nexport default class ActionForm extends HTMLElement {\n\tpublic form = (this.querySelector(\"form\") as HTMLFormElement) || null;\n\n\t/* ----------------------------- Create storeKey ---------------------------- */\n\t// Store key is based on the store attribute or if not defined then ids or random values\n\tpublic storeKey: string = this.hasAttribute(\"store\") ? this.getAttribute(\"store\") || `action-form-${this.id || this.form.id || randomId()}` : \"\";\n\n\t/* -------- Persisted fields are ones that are maintained thru reset -------- */\n\tprivate persistedFields: HTMLFormField[] = [];\n\n\t/* --------------------------- Reactive form data --------------------------- */\n\t// used for error triggers and data-if and data-text\n\tpublic data = formSignals(this.form);\n\n\t/* ----------------------------- Reactive steps ----------------------------- */\n\tpublic steps = stepSignals(this.querySelectorAll(\"af-step\") as NodeListOf<ActionFormStep>);\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst form = this.form;\n\t\tif (form) {\n\t\t\t/*\n\t\t\t * Set novalidate on the form if novalidate set on action-form.\n\t\t\t * This way novalidate is only set if javascript is loaded and form-action is defined.\n\t\t\t * We want to allow falling back to browser validation if javascript is not loaded.\n\t\t\t */\n\t\t\tif (this.hasAttribute(\"novalidate\")) {\n\t\t\t\tform.setAttribute(\"novalidate\", \"\");\n\t\t\t}\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*                                Local Storage                               */\n\t\t\t/* -------------------------------------------------------------------------- */\n\n\t\t\t/* --------------------- Make array of persisted fields --------------------- */\n\t\t\tthis.persistedFields = Array.from(this.querySelectorAll(\"[data-persist]\")).filter((el) => isField(el)) as HTMLFormField[];\n\n\t\t\t/* ----------------- Restore form values if store is enabled ---------------- */\n\t\t\tif (this.storeKey) {\n\t\t\t\tthis.restoreFieldValues();\n\t\t\t}\n\n\t\t\t/* ------------------- Listen for storage events to update ------------------ */\n\t\t\twindow.addEventListener(\"storage\", (event) => {\n\t\t\t\tthis.log(\"storage\", event, event.key);\n\n\t\t\t\tif (this.hasAttribute(\"store-listen\") && event.key === this.storeKey) {\n\t\t\t\t\tthis.restoreFieldValues();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*                               Set up af-steps                              */\n\t\t\t/* -------------------------------------------------------------------------- */\n\n\t\t\t/* --------- create effect to set the active step and the step index -------- */\n\n\t\t\tcreateEffect(() => {\n\t\t\t\tthis.log(\"ðŸ«¨ create effect ~ action-form: step activation\");\n\t\t\t\tconst currentStep = this.steps.currentStep();\n\t\t\t\tthis.steps.all.forEach((step) => {\n\t\t\t\t\tif (step === currentStep) {\n\t\t\t\t\t\tstep.classList.add(\"active\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstep.classList.remove(\"active\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*              Add ids as needed to all fieldsets and fields                 */\n\t\t\t/* -------------------------------------------------------------------------- */\n\n\t\t\t// Create array of all fieldGroups and fields that require validation\n\t\t\tconst fieldGroups = Array.from(this.querySelectorAll(\"af-field-group\")) as Array<ActionFormFieldGroup>;\n\t\t\tconst validationFields = Array.from(this.querySelectorAll(\"[required],[pattern],[type=phone],[type=email],[type=url],[minlength],[maxlength]\")) as Array<HTMLFormField>;\n\n\t\t\t[...fieldGroups, ...validationFields].forEach((el) => {\n\t\t\t\tif (!el.id) {\n\t\t\t\t\tel.id = randomId(`${el.tagName.toLowerCase()}${el.name ? `-${el.name}` : \"\"}`);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*      If auto-error, add af-error to all fields that require validation     */\n\t\t\t/* -------------------------------------------------------------------------- */\n\n\t\t\t// Find all fields that require validation error messages\n\t\t\tif (this.hasAttribute(\"auto-error\")) {\n\t\t\t\tvalidationFields.forEach((field) => {\n\t\t\t\t\t// ignore if field has aria-describedby attribute as that means it already has an error message\n\t\t\t\t\tif (field.hasAttribute(\"aria-describedby\")) return;\n\n\t\t\t\t\t// Check if there is an af-error attribute for the field, either by id or withing parent label\n\t\t\t\t\tconst errorById = form.querySelector(`af-error[for=\"${field.id}\"]`);\n\t\t\t\t\tconst errorByProximity = field.closest(\"label\")?.querySelector(`af-error`);\n\t\t\t\t\tif (!errorById && !errorByProximity) {\n\t\t\t\t\t\tfield.after(this.createAfError(field));\n\t\t\t\t\t\t// NOTE: the af-error component will add it's own id and the aria-describedby attribute\n\t\t\t\t\t\tthis.log(`Added Error Message for ${field.id}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// Find all fieldsets with data-group that don't have an aria-describedby\n\t\t\t\tfieldGroups.forEach((fieldGroup) => {\n\t\t\t\t\t// ignore if fieldset has aria-describedby attribute as that means it already has an error message\n\t\t\t\t\tif (fieldGroup.hasAttribute(\"aria-describedby\")) return;\n\n\t\t\t\t\t// search for any matching af-error messages\n\t\t\t\t\tconst afError = fieldGroup.querySelector(`af-error[for=\"${fieldGroup.id}\"]`);\n\t\t\t\t\t// if no error message found, create one\n\t\t\t\t\tif (!afError) {\n\t\t\t\t\t\tfieldGroup.append(this.createAfError(fieldGroup));\n\t\t\t\t\t\tthis.log(`Added Error Message for ${fieldGroup.id}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*                      Reactive form state management                        */\n\t\t\t/* -------------------------------------------------------------------------- */\n\n\t\t\t/* --- Set up reactive form state management with all field names as keys --- */\n\n\t\t\t// 1. Create keys from names of all field elements\n\t\t\tconst keys = new Set(\n\t\t\t\tArray.from(form.elements)\n\t\t\t\t\t.map((el) => {\n\t\t\t\t\t\t// @ts-expect-error checking for name\n\t\t\t\t\t\treturn el.name || \"\";\n\t\t\t\t\t})\n\t\t\t\t\t.filter((name) => name)\n\t\t\t);\n\n\t\t\t// 2. Set up data with all field element names\n\t\t\tkeys.forEach((key) => {\n\t\t\t\tthis.data.set(key);\n\t\t\t});\n\n\t\t\t/* -------------- Change event listener which triggers data.set ------------- */\n\n\t\t\tform.addEventListener(\"change\", (e) => {\n\t\t\t\t// trigger any events mapped to the form\n\t\t\t\tconst target = e.target;\n\t\t\t\tif (target instanceof HTMLElement) {\n\t\t\t\t\t// @ts-expect-error this is an if on purpose\n\t\t\t\t\tif (target.name) {\n\t\t\t\t\t\t// @ts-expect-error checking for name\n\t\t\t\t\t\t// 1. trigger any events mapped to name of the field\n\t\t\t\t\t\tthis.data.set(target.name);\n\t\t\t\t\t\t// 2. trigger any general events (mapped to the form element)\n\t\t\t\t\t\tthis.data.setForm();\n\t\t\t\t\t}\n\t\t\t\t\t// 3. Store the data if store is set\n\t\t\t\t\tif (this.storeKey) localStorage.setItem(this.storeKey, JSON.stringify(this.data.formDataObject()));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*    Add effect to all fields and af-field-group to check toggle errors      */\n\t\t\t/* -------------------------------------------------------------------------- */\n\n\t\t\t[...validationFields, ...fieldGroups].forEach((el) => {\n\t\t\t\t// create effect to check all fields that require validation to toggle errors\n\t\t\t\tcreateEffect(() => {\n\t\t\t\t\tthis.log(\"ðŸ«¨ create effect ~ action-form: error checking\");\n\t\t\t\t\tthis.data.get(el.name);\n\t\t\t\t\tthis.toggleError(el);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*                           Enhance normal elements                          */\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/* ---------------------- Set up data-if and data-text ---------------------- */\n\t\t\tconst enhancedElements = this.querySelectorAll(\"[data-if],[data-text]\");\n\n\t\t\tenhancedElements.forEach((el) => {\n\t\t\t\tif (el instanceof HTMLElement) {\n\t\t\t\t\tconst dataIf = el.dataset.if;\n\t\t\t\t\tconst dataText = el.dataset.text;\n\t\t\t\t\t// 1. create effect for data-if and data-text\n\t\t\t\t\tcreateEffect(() => {\n\t\t\t\t\t\tthis.log(\"ðŸ«¨ create effect: action-form: enhance elements\");\n\t\t\t\t\t\tif (dataIf) {\n\t\t\t\t\t\t\tconst fieldValues = this.data.get(dataIf);\n\t\t\t\t\t\t\tif (fieldValues) {\n\t\t\t\t\t\t\t\tconst value = el.dataset.ifValue;\n\t\t\t\t\t\t\t\tconst notValue = el.dataset.ifNotValue;\n\t\t\t\t\t\t\t\tconst regexStr = el.dataset.ifRegex;\n\t\t\t\t\t\t\t\tconst regex: RegExp | undefined = regexStr ? new RegExp(regexStr) : undefined;\n\t\t\t\t\t\t\t\tif (value || notValue || regex) {\n\t\t\t\t\t\t\t\t\t// matches checks if any of the values are equal to the ifValue or if it matches via regex to the ifRegex if none of the values equal the notValue\n\t\t\t\t\t\t\t\t\tconst matches =\n\t\t\t\t\t\t\t\t\t\tfieldValues.some((d) => typeof d === \"string\" && ((value && d === value) || (regex && regex.test(d)))) &&\n\t\t\t\t\t\t\t\t\t\tfieldValues.every((d) => typeof d === \"string\" && (!notValue || d !== notValue));\n\t\t\t\t\t\t\t\t\t// this.log(\"matches\", watch, value, matches, data);\n\t\t\t\t\t\t\t\t\tthis.show(el, matches);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// if there is no ifValue, ifNotValue or ifRegex then just show the element as long as there is at least some value\n\t\t\t\t\t\t\t\t\tthis.show(el, !!fieldValues.some((d) => !!d));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dataText) {\n\t\t\t\t\t\t\tconst fieldValues = this.data.get(dataText);\n\t\t\t\t\t\t\tif (fieldValues) {\n\t\t\t\t\t\t\t\tel.textContent = fieldValues?.toString();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*                            Override reset button                           */\n\t\t\t/* -------------------------------------------------------------------------- */\n\n\t\t\tconst resetButtons = this.querySelectorAll(\"button[type=reset]\");\n\t\t\t// There is a specific order to resetting that needs done so as to not reset persisted fields\n\t\t\tresetButtons.forEach((resetBtn) => {\n\t\t\t\tresetBtn.addEventListener(\"click\", (event) => {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t// store the persisted fields values (works with out localStorage being enabled)\n\t\t\t\t\tthis.persistedFields.forEach((persistField) => (isField(persistField) ? (persistField.dataset.persist = persistField.value) : null));\n\t\t\t\t\t// reset the form\n\t\t\t\t\tthis.form.reset();\n\t\t\t\t\t// restore the persisted fields\n\t\t\t\t\tthis.persistedFields.forEach((persistField) =>\n\t\t\t\t\t\tisField(persistField) && typeof persistField.dataset.persist === \"string\" ? (persistField.value = persistField.dataset.persist) : null\n\t\t\t\t\t);\n\t\t\t\t\t// restore the form to initial state; resetting store to only persisted fields and setting step to 0\n\t\t\t\t\tthis.restoreForm();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\t/*                       Validate form before submitting                      */\n\t\t\t/* -------------------------------------------------------------------------- */\n\t\t\tthis.addEventListener(\"submit\", (e) => {\n\t\t\t\t// Validate form before submitting\n\t\t\t\tconst formValid = form.checkValidity();\n\t\t\t\tif (!formValid) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tconst invalidField = this.form.querySelector(\":invalid:not(fieldset)\");\n\t\t\t\t\t// if there is an invalid field, focus on it and highlight the error by triggering the change event\n\t\t\t\t\tif (invalidField && invalidField instanceof HTMLElement) {\n\t\t\t\t\t\t// find parent af-step element\n\t\t\t\t\t\tconst parentStep = invalidField.closest(\"af-step\");\n\t\t\t\t\t\t// find index of parent step\n\t\t\t\t\t\t// const stepIndex: number = 0;\n\t\t\t\t\t\tconst stepIndex = this.steps.getVisible().findIndex((step) => step === parentStep);\n\t\t\t\t\t\t// set step index\n\t\t\t\t\t\tif (stepIndex !== -1) {\n\t\t\t\t\t\t\t// got to step index\n\t\t\t\t\t\t\tthis.steps.set(stepIndex);\n\t\t\t\t\t\t\t// trigger next which will find error\n\t\t\t\t\t\t\tthis.steps.next();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(`Invalid field: ${invalidField.id}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// If form is valid then erase the stored values except for persisted fields\n\t\t\t\t\tthis.restoreForm();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate createAfError(el: ActionFormFieldGroup | HTMLFormField): ActionFormError {\n\t\tconst afError = document.createElement(\"af-error\") as ActionFormError;\n\t\tafError.setAttribute(\"for\", el.id);\n\t\tafError.textContent = el.dataset.error || \"\";\n\t\tif (el.dataset.errorPattern) {\n\t\t\tconst pattern = document.createElement(\"span\");\n\t\t\tpattern.setAttribute(\"slot\", \"pattern\");\n\t\t\tpattern.textContent = el.dataset.errorPattern;\n\t\t\tafError.append(pattern);\n\t\t}\n\t\treturn afError;\n\t}\n\n\tprivate toggleError(el: HTMLFormField | ActionFormFieldGroup) {\n\t\tconst errorMsg = document.getElementById(el.getAttribute(\"aria-describedby\") || \"\");\n\t\tif (errorMsg && typeof el.checkValidity === \"function\") {\n\t\t\tconst valid = el.checkValidity();\n\t\t\tthis.log(\"errorMsg.id, valid\", errorMsg.id, valid);\n\t\t\tif (valid) {\n\t\t\t\tthis.resetError(el, errorMsg);\n\t\t\t} else {\n\t\t\t\terrorMsg.style.visibility = \"visible\";\n\t\t\t\tel.setAttribute(\"aria-invalid\", \"true\");\n\t\t\t\terrorMsg.dataset.invalid = el.value === \"\" ? \"required\" : \"pattern\";\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate resetError(el: HTMLFormField | ActionFormFieldGroup, errorMsg: HTMLElement) {\n\t\tel.removeAttribute(\"aria-invalid\");\n\t\terrorMsg.style.visibility = \"hidden\";\n\t\terrorMsg.removeAttribute(\"data-invalid\");\n\t}\n\n\tprivate restoreForm() {\n\t\t// Remove store except for persisted fields\n\t\tthis.resetStore();\n\n\t\t// Reset all elements and their error messages\n\t\tconst erroredElements = this.querySelectorAll(\"[aria-invalid]\");\n\t\terroredElements.forEach((el) => {\n\t\t\tif (isFieldOrGroup(el)) {\n\t\t\t\tconst errorMsg = document.getElementById(el.getAttribute(\"aria-describedby\") || \"\");\n\t\t\t\tif (errorMsg) this.resetError(el, errorMsg);\n\t\t\t}\n\t\t});\n\n\t\t// Move back to step 0\n\t\t// this.step.set(0);\n\t}\n\n\tprivate resetStore() {\n\t\t// Remove store except for persisted fields\n\t\tconst ls = localStorage.getItem(this.storeKey);\n\t\t// If there are persisted field then maintain them\n\t\tif (ls && this.persistedFields.length > 0) {\n\t\t\tconst values = JSON.parse(ls) as Record<string, string | string[]>;\n\t\t\tObject.keys(values).forEach((key) => {\n\t\t\t\tif (this.persistedFields.every((field) => field.name !== key)) {\n\t\t\t\t\tdelete values[key];\n\t\t\t\t}\n\t\t\t});\n\t\t\t// set store with only persisted fields\n\t\t\tlocalStorage.setItem(this.storeKey, JSON.stringify(values));\n\t\t} else {\n\t\t\tlocalStorage.removeItem(this.storeKey);\n\t\t}\n\t}\n\n\tprivate restoreFieldValues() {\n\t\tconst ls = localStorage.getItem(this.storeKey);\n\t\tif (!ls || ls === \"undefined\") return;\n\t\tconst values = JSON.parse(ls) as Record<string, string | string[]>;\n\t\tif (typeof values !== \"object\") return;\n\t\t// Cycle through fields based on name\n\t\tObject.keys(values).forEach((key) => {\n\t\t\tconst fields = this.querySelectorAll(`[name=\"${key}\"]`);\n\t\t\tfields.forEach((el) => {\n\t\t\t\tif (isField(el) && !el.matches(\"[type=hidden]\")) {\n\t\t\t\t\t// if this is a checkbox or radio button\n\t\t\t\t\tif (el instanceof HTMLInputElement && [\"checkbox\", \"radio\"].includes(el.type) && values[key] instanceof Array) {\n\t\t\t\t\t\t// set checked based on value in array\n\t\t\t\t\t\tel.checked = values[key].includes(el.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// set value\n\t\t\t\t\t\tel.value = String(values[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate show(el: HTMLElement, show: boolean): void {\n\t\t// this.log(\"show\", el, show);\n\t\tif (show) {\n\t\t\tel.style.display = \"\";\n\t\t\tel.removeAttribute(\"disabled\");\n\t\t} else {\n\t\t\tel.style.display = \"none\";\n\t\t\tel.setAttribute(\"disabled\", \"\");\n\t\t}\n\t\tel.dispatchEvent(new Event(\"change\", { bubbles: true }));\n\t\tif (el.matches(\"af-step\")) this.steps.updateSteps();\n\t\tif (el.matches(\"fieldset\")) {\n\t\t\t// if this is a fieldset, set all named events so that errors, data-if and data-text events can be updated\n\t\t\tconst fields = el.querySelectorAll(\"input, select, textarea\") as NodeListOf<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>;\n\t\t\tfields.forEach((field) => {\n\t\t\t\t// console.log(\"show notify\", field.name);\n\t\t\t\tthis.data.set(field.name);\n\t\t\t});\n\t\t}\n\t}\n\n\t// eslint-disable-next-line\n\tprivate log(...args: any[]): void {\n\t\t// eslint-disable-next-line no-console\n\t\tif (this.hasAttribute(\"debug\")) console.log(...args);\n\t}\n\n\t// public connectedCallback(): void {\n\t// \tthis.log(\"connected\");\n\t// }\n\n\t// public attributeChangedCallback(name: string, oldValue: string, newValue: string) {\n\t// \tthis.log(\"changed\", name, oldValue, newValue);\n\t// }\n}\ncustomElements.define(\"action-form\", ActionForm);\n\n// Define imported elements that are required by this component\ncustomElements.define(\"af-error\", ActionFormError);\n"],"names":["randomId","prefix","isField","el","isFieldOrGroup","ActionFormFieldGroup","ActionFormError","__publicField","target","id","targetId","_a","name","_oldValue","newValue","part","parts","formSignals","form","map","getForm","setFormData","createSignal","formDataObject","setForm","set","key","values","getValues","get","keys","tempObject","stepSignals","afSteps","stepIndex","setStepIndex","currentStep","setCurrentStep","getVisible","stepsLength","setStepsLength","step","updateSteps","number","move","numberOfSteps","currentIndex","index","prev","next","invalid","ActionForm","event","createEffect","fieldGroups","validationFields","field","errorById","errorByProximity","fieldGroup","dataIf","dataText","fieldValues","value","notValue","regexStr","regex","matches","d","resetBtn","persistField","invalidField","parentStep","afError","pattern","errorMsg","valid","ls","show","args"],"mappings":"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"}